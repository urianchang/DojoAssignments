==========================
| Login and Registration |
==========================

Key pieces:
    * Two angular forms: one for login, one for registration, these can be on a single controller
    * An angular factory that can make a request to our server
    * A server and associated files, that has a user model and controller associated with mongoose

==========
| BCrypt |
==========

generate_password_hash: BcryptJS has a handy password hash generator function
that we can use when creating new users:

        var bcrypt = require('bcryptjs');   // or 'bcrypt' on some versions
        bcrypt.hashSync(password, bcrypt.genSaltSync(8));
        //: Password checker
        bcrypt.compareSync(password, this.password);

======================================
| Mongoose Models Methods, Pre, Post |
======================================

When we generate a mongoose model:

        //...
        var myModelSchema= new mongoose.Schema({
        name: {type:String}
        // info here!
        }, { timestamps: true
        });

        // for older version, use the following timestamp
        //{ timestamps:
        //  { createdAt: 'created_at' },
        //  { updatedAt: 'updated_at'}
        // });

        //custom methods, pre, post etc. here
        myModelSchema.methods.addJayToString = function(input){
        return input+"Jay";
        }
        /* What pre does prior to saving:
        Starting with an instance of our model:
        e.g.  var MyModel = mongoose.model('myModelName');
            var myModelInstance = new MyModel({name: "The Amazing "});
        When we try to save our model:
        e.g.  myModelInstance.save();
        Pre runs before saving.  In the example below: It would add "Jay to our current name ("The Amazing")" and "The Amazing Jay" would be stored in our DB.
        */
        myModelSchema.pre('save', function(done){
        this.name = this.addJayToString(this.name);
        done();
        });


        /*
        We can also call the methods e.g. addJayToString directly on the instance, if we didn't want to use 'pre'.  e.g.
        var MyModel = mongoose.model('myModelName');
        var myModelInstance = new MyModel({name: "The Amazing "});
        console.log(myModelInstance.addJayToString("hello "));
        This would just console.log "hello Jay";


        */
        mongoose.model('myModelName', myModelSchema);
        //...

=================
| Error Objects |
=================

Mongoose has prebuilt validations for various schema types (http://mongoosejs.com/docs/validation.html).

Mongoose errors generated by these validations are passed back to an object that is caught
by the mongoose method callback as the first (err) parameter passed to that callback.

Ex:

        // in the mongoose controller
        // ...
        this.create = function(myData){
          var newThing = new Thing();
          // function(err,thing){} is a callback,
          // err is the first parameter, if there is an error with that method.
          newThing.save(function(err, thing){
            //do stuff with err and thing
          });
        }
        // ...

Example of error message:

        err = {
              errors:
                  {
                  schemaInThing_that_had_error:
                      {
                        message:"some string of errors",
                        kind:"what didn't work",
                        path:"reference to the schema's name",
                        value:"cause of the initial error"


                      }
                  },
              name: "Validation error"
              }

======================
| Custom Validations |
======================

Example:

        var mongoose       = require('mongoose'),
            Schema         = mongoose.Schema,
            customerSchema = new Schema({
              name: {
                first: {
                  type: String,
                  required: [true, "this is for something else"],
                  trim: true,
                },
                last: {
                  type: String,
                  required: true,
                  trim: true
                },
              },


              phone: {
                type: String,
                validate: [{
                  validator: function( number ) {
                    return /\d{3}-\d{3}-\d{4}/.test( number );
                  },
                  message: "{ VALUE } is not a valid phone number"
                },
                {
                  validator: function( number ) {
                    return false;
                  },
                  message: "{ VALUE } failed this validator"
                }
              ],
                required: [true, "Customer phone number required"]
              },


              gender: {
                type: String,
                enum: ['MALE', 'FEMALE'],
                uppercase: true,
                trim: true,
                default: "MALE"
              },


              age: {
                type: Number,
                min: [18, "Maybe you need to be a little older"],
                max: [85, "You might want to be enjoying your retirement rather than using this site"],
                required: true
              },


              password: {
                type: String,
                required: true,
                minlength: 8,
                maxlength: 32,
                validate: {
                  validator: function( value ) {
                    return /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[$@$!%*?&])[A-Za-z\d$@$!%*?&]{8,32}/.test( value );
                  },
                  message: "Password failed validation, you must have at least 1 number, uppercase and special character"
                }
              },


              pets: {
                type: [{
                  type: Schema.Types.ObjectId,
                  ref: "Pet"
                }],
                default: []
              }


              }, {
              timestamps: {
                createdAt: 'created_at',
                updatedAt: 'updated_at'
              }
            });


        customerSchema.virtual( 'name.full' ).get( function () {
          return this.name.first + " " + this.name.last;
          // return `${ this.name.first } ${ this.name.last}`;
        });

The anonymous function is passed the input value and a boolean value is returned.
If the boolean is false, then an error is triggered.
